Next.js uses a **file-based routing system**, which means that **the structure of your applicationâ€™s routes is determined directly by the files and folders inside a special directory (`app/` or `pages/`)**.
You donâ€™t manually create route definitions like in Express or React Routerâ€”Next.js automatically converts files into routes.

Below is a deep, clear breakdown.

---

# âœ… What â€œfile-based routingâ€ means

In Next.js, your route URLs correspond directly to the organization of files in your project.

Example (`/pages` or `/app` directory):

```
app/
 â”œâ”€â”€ page.js
 â”œâ”€â”€ dashboard/
 â”‚     â””â”€â”€ page.js
 â”œâ”€â”€ blog/
 â”‚     â”œâ”€â”€ page.js
 â”‚     â””â”€â”€ [slug]/
 â”‚           â””â”€â”€ page.js
```

This creates these routes:

| File or folder            | URL route               |
| ------------------------- | ----------------------- |
| `app/page.js`             | `/`                     |
| `app/dashboard/page.js`   | `/dashboard`            |
| `app/blog/page.js`        | `/blog`                 |
| `app/blog/[slug]/page.js` | `/blog/:slug` (dynamic) |

You do _not_ write route configurationâ€”Next.js interprets the filesystem for you.

---

# âœ… Why this matters

A file-based routing system:

### âœ”ï¸ Saves time

You don't need routing boilerplate.

### âœ”ï¸ Enforces structure

Team members can see routes simply by looking at the folder layout.

### âœ”ï¸ Supports dynamic segments automatically

Use square brackets (`[param]`) for dynamic routes.

Example:
`app/products/[id]/page.js` â†’ `/products/123`

### âœ”ï¸ Supports server & client components

Routing works seamlessly with the new App Router (Next.js 13+).

---

# How Next.js routing works (step by step)

### 1. **Every folder can represent a route segment**

A segment = part of a URL.

Example:
`/dashboard/settings/profile`

This could map to:

```
app/
 â””â”€â”€ dashboard/
       â””â”€â”€ settings/
             â””â”€â”€ profile/
                   â””â”€â”€ page.js
```

### 2. **`page.js` makes a route public**

A folder becomes an actual URL only if it contains a `page.js` file.

### 3. **Dynamic routes use brackets**

- `[id]` â†’ dynamic route parameter
- `[...slug]` â†’ catch-all
- `[[...slug]]` â†’ optional catch-all

### 4. **Layouts provide shared UI across segments**

`layout.js` wraps `page.js` within the same folder.

Example:

```
app/dashboard/layout.js   â‡¢ wraps all dashboard pages
app/dashboard/page.js
```

### 5. **Routing supports nested layouts, metadata, loading states, and more**

- `loading.js`
- `error.js`
- `template.js`
- `route.js` (for API endpoints)

---

# App Router vs Pages Router (Quick Explanation)

### **App Router (`app/`)**

- Introduced in Next.js 13
- Uses React Server Components
- `page.js`
- `layout.js`
- dynamic rendering, streaming, etc.

### **Pages Router (`pages/`)**

- Classic Next.js routing
- Each file = route
- `pages/blog/[slug].js`

Both use file-based routing, but **App Router is now the primary modern system**.

---

# Summary (simple version)

â€œ**Next.js uses a file-based routing system**â€ means:

> **You create files and folders, and Next.js automatically turns them into URL routesâ€”no manual route configuration required.**

This makes routing:

- simpler
- more predictable
- more scalable

---

Great â€” here are the three deeper expansions you asked for:
**(1) visual diagrams, (2) App Router vs Pages Router examples, and (3) a small sample project showing best practices.**

---

# ğŸŸ¦ 1. VISUAL DIAGRAMS OF ROUTING

## **A. How Next.js converts folders â†’ URL segments**

```
app/
 â”œâ”€â”€ dashboard/
 â”‚     â”œâ”€â”€ analytics/
 â”‚     â”‚       â””â”€â”€ page.js
 â”‚     â””â”€â”€ page.js
 â””â”€â”€ blog/
       â”œâ”€â”€ [slug]/
       â”‚      â””â”€â”€ page.js
       â””â”€â”€ page.js
```

Produces these routes:

```
/
 /dashboard
 /dashboard/analytics
 /blog
 /blog/:slug   (dynamic segment)
```

Think of it like a â€œmapâ€:

```
app/
 â”œâ”€â”€ segment A/
 â”‚      â””â”€â”€ segment B/
 â”‚             â””â”€â”€ page.js  âœ /A/B
 â””â”€â”€ dynamic segment /
        â””â”€â”€ [id]/page.js  âœ /:id
```

---

## **B. Diagram: Page, Layout, Template, Loading, Error**

```
app/
 â””â”€â”€ dashboard/
       â”œâ”€â”€ layout.js
       â”œâ”€â”€ loading.js
       â”œâ”€â”€ error.js
       â”œâ”€â”€ template.js
       â””â”€â”€ page.js
```

**Rendering hierarchy:**

```
layout.js
   â””â”€â”€ template.js (optional)
         â””â”€â”€ loading.js (shows during load)
         â””â”€â”€ error.js (if something fails)
         â””â”€â”€ page.js (final UI)
```

**Intuition:**

- **layout.js** = permanent frame (sidebar, nav)
- **template.js** = copy-on-render wrapper
- **loading.js** = suspense placeholder
- **error.js** = boundary for exceptions
- **page.js** = the actual route content

---

# ğŸŸ¦ 2. APP ROUTER vs PAGES ROUTER â€” SIDE-BY-SIDE EXAMPLES

## **A. Simple route**

### **App Router (`app/`)**

```
app/about/page.js  â†’ /about
```

### **Pages Router (`pages/`)**

```
pages/about.js    â†’ /about
```

---

## **B. Dynamic route**

### **App**

```
app/products/[id]/page.js  â†’ /products/123
```

### **Pages**

```
pages/products/[id].js     â†’ /products/123
```

---

## **C. Nested layouts (App Router ONLY)**

```
app/dashboard/layout.js
app/dashboard/settings/page.js
```

**Effect:**
`layout.js` wraps **every** dashboard pageâ€”like global UI for that section.

Pages Router has **no built-in nested layouts**, so you'd manually place layout components inside each page.

---

## **D. Server/Client Components**

| Feature                     | App Router          | Pages Router    |
| --------------------------- | ------------------- | --------------- |
| Server Components           | âœ”ï¸ yes              | âŒ no           |
| Nested layouts              | âœ”ï¸ yes              | âŒ no           |
| Route-level loading states  | âœ”ï¸ yes              | âŒ no           |
| Route handlers (`route.js`) | âœ”ï¸ yes              | âŒ no           |
| API routes                  | âœ”ï¸ yes (`route.js`) | âœ”ï¸ yes (`api/`) |
| Client-side navigation      | âœ”ï¸ yes              | âœ”ï¸ yes          |

**Takeaway:**
**App Router = modern, server-first, scalable routing.**
**Pages Router = legacy but still supported.**

---

# ğŸŸ¦ 3. MINI PROJECT: â€œBlog + Dashboardâ€ ROUTING STRUCTURE

A clean, professional Next.js routing setup.

```
app/
 â”œâ”€â”€ layout.js        (global layout)
 â”œâ”€â”€ page.js          (homepage)
 â”œâ”€â”€ dashboard/
 â”‚     â”œâ”€â”€ layout.js   (dashboard layout)
 â”‚     â”œâ”€â”€ page.js     (dashboard home)
 â”‚     â””â”€â”€ analytics/
 â”‚           â””â”€â”€ page.js
 â””â”€â”€ blog/
       â”œâ”€â”€ page.js         (blog index)
       â”œâ”€â”€ [slug]/
       â”‚      â”œâ”€â”€ page.js  (single post)
       â”‚      â”œâ”€â”€ loading.js
       â”‚      â”œâ”€â”€ error.js
       â”‚      â””â”€â”€ not-found.js
       â””â”€â”€ category/
             â””â”€â”€ [name]/
                    â””â”€â”€ page.js
```

### **Resulting Routes**

```
/                         â†’ app/page.js
/dashboard                â†’ app/dashboard/page.js
/dashboard/analytics      â†’ app/dashboard/analytics/page.js
/blog                     â†’ app/blog/page.js
/blog/<slug>              â†’ dynamic blog post
/blog/category/<name>     â†’ category page
```

### **API Routes with App Router**

```
app/api/posts/route.js        â†’ /api/posts
app/api/posts/[id]/route.js   â†’ /api/posts/:id
```

---

# ğŸŸ¦ 4. Best practices (high-value tips)

### âœ”ï¸ Use `app/` router for all new projects

Much more powerful and modern.

### âœ”ï¸ Use layouts for sections with shared UI

Dashboard, admin areas, settings pages, etc.

### âœ”ï¸ Keep routes shallow

Avoid `app/a/b/c/d/e/f/...` unless absolutely necessary.

### âœ”ï¸ Prefer server components by default

Only add `"use client"` when needed.

### âœ”ï¸ Name dynamic segments clearly

Good:

```
[productId]
```

Bad:

```
[id]
```

### âœ”ï¸ Use `generateMetadata` for better SEO

Built-in to app router.

---

Here is a **complete, high-value Next.js Routing Cheat Sheet** covering **every routing convention** for both the **App Router** (`app/`) and **Pages Router** (`pages/`).
Clean, structured, and ready for practical use.

---

# ğŸŸ¦ **NEXT.JS ROUTING CHEAT SHEET**

## â­ Covers: App Router + Pages Router + File Naming + Special Files + API Routes + Dynamic Segments + URL Params + Metadata

---

# 1. ğŸ“ **Basic Routing (App Router)**

| File / Folder           | URL          |
| ----------------------- | ------------ |
| `app/page.js`           | `/`          |
| `app/about/page.js`     | `/about`     |
| `app/shop/cart/page.js` | `/shop/cart` |

âœ” Every folder = a URL segment
âœ” Every `page.js` = a routable page

---

# 2. ğŸ”¤ **Dynamic Routes**

### **App Router**

| Pattern           | Meaning            | URL Example                   |
| ----------------- | ------------------ | ----------------------------- |
| `[id]`            | dynamic param      | `/product/123`                |
| `[slug]`          | dynamic string     | `/blog/how-to-code`           |
| `[...segments]`   | catch-all          | `/docs/getting-started/setup` |
| `[[...segments]]` | optional catch-all | `/docs` or `/docs/setup`      |

### Accessing params (App Router):

```js
export default function Page({ params }) {
  return <div>{params.id}</div>;
}
```

---

# 3. ğŸ§© **Route Hierarchy (App Router)**

Inside any route folder:

| File                     | Purpose                                    |
| ------------------------ | ------------------------------------------ |
| `page.js`                | The actual page                            |
| `layout.js`              | Persistent UI wrapper (header/sidebar)     |
| `template.js`            | Re-rendering wrapper for navigation events |
| `loading.js`             | Suspense loading UI                        |
| `error.js`               | Error boundary                             |
| `not-found.js`           | 404 for that segment                       |
| `route.js`               | API endpoint                               |
| `head.js` _(deprecated)_ | Older metadata                             |

Render order:

```
layout.js
 â””â”€â”€ template.js (optional)
       â””â”€â”€ loading.js (while waiting)
       â””â”€â”€ error.js (if crashed)
       â””â”€â”€ page.js
```

---

# 4. ğŸ›  **API Routes (App Router)**

File:

```
app/api/posts/route.js
```

Methods inside:

```js
export function GET() { ... }
export function POST() { ... }
export function PUT() { ... }
export function DELETE() { ... }
```

Produces route:

```
/api/posts
```

Dynamic API route:

```
app/api/posts/[id]/route.js â†’ /api/posts/:id
```

---

# 5. ğŸ§­ **Navigation**

### Client Components

```jsx
import Link from 'next/link';

<Link href='/dashboard'>Go</Link>;
```

### Programmatic routing

```jsx
'use client';
import { useRouter } from 'next/navigation';
const router = useRouter();

router.push('/login');
router.replace('/dashboard');
router.back();
```

---

# 6. ğŸ“° **Metadata Routing (SEO)**

### Option 1: Static metadata

```js
export const metadata = {
  title: 'My Page',
  description: 'About this page'
};
```

### Option 2: Dynamic metadata

```js
export function generateMetadata({ params }) {
  return {
    title: `Post: ${params.slug}`
  };
}
```

---

# 7. ğŸ“„ **Parallel Routes (Advanced App Router)**

Allows independent UI trees in one route.

```
app/dashboard/
 â”œâ”€â”€ layout.js
 â”œâ”€â”€ @reports/page.js
 â””â”€â”€ @users/page.js
```

Use case: multi-panel dashboards.

---

# 8. ğŸ“Œ **Intercepting Routes (`(..)` syntax)**

Used to overlay content without leaving the original page.

| Syntax     | Meaning       |
| ---------- | ------------- |
| `(.)`      | Same level    |
| `(..)`     | One level up  |
| `(..)(..)` | Two levels up |
| `(...)`    | Root          |

Example:

```
app/feed/(..)post/[id]/page.js
```

Shows post as a modal over `/feed`.

---

# 9. ğŸ—‚ **Pages Router (Legacy) Quick Reference**

### File â†’ Route mappings

```
pages/index.js      â†’  /
pages/about.js      â†’  /about
pages/blog/[id].js  â†’  /blog/123
```

### Dynamic routes

```
[id].js
[...slug].js
```

### API routes

```
pages/api/users.js        â†’ /api/users
pages/api/users/[id].js   â†’ /api/users/:id
```

### Data fetching

- `getStaticProps`
- `getServerSideProps`
- `getStaticPaths`

(Not used in App Router.)

---

# 10. ğŸ” **URL Search Params (App Router)**

Use `searchParams`:

```js
export default function Page({ searchParams }) {
  return <div>{searchParams.q}</div>;
}
```

Route:

```
/search?q=hello
```

---

# 11. â­ Special Folders Summary

| Folder/Name | Meaning                         |
| ----------- | ------------------------------- |
| `(group)`   | URL-less group for organization |
| `@slot`     | parallel route                  |
| `[param]`   | dynamic segment                 |
| `(.)route`  | intercepting route              |
| `route.js`  | API route                       |
| `layout.js` | persistent wrapper              |
| `page.js`   | actual page                     |

---

# 12. ğŸŸ£ **Common Folder Patterns Cheat Sheet**

| Purpose                | Folder Structure                        |
| ---------------------- | --------------------------------------- |
| Blog index             | `app/blog/page.js`                      |
| Blog post              | `app/blog/[slug]/page.js`               |
| Dashboard with sidebar | `app/dashboard/layout.js` + child pages |
| Modal on top of list   | `app/items/(..)modal/[id]/page.js`      |
| Catch-all docs         | `app/docs/[...slug]/page.js`            |
| Multi-panel dashboard  | `app/dashboard/@panel/page.js`          |

---

params prop

Each react component has access to the params object containing the dynamic route segments. It's a prop passed to the component by Next.js. and can be accessed like this:

```js
const page = ({ params }: { params: { id: string } }) => {
  return <div>User Profile for ID: {params.id} under development...</div>;
};
```

---

An **ORM (Objectâ€“Relational Mapping)** is a programming techniqueâ€”and usually a library or frameworkâ€”that lets you interact with a **relational database (like PostgreSQL, MySQL, SQLite)** using **objects and code**, instead of writing raw SQL queries.

---

# âœ… **What an ORM Does**

An ORM maps:

**Database tables â†’ Classes**
**Rows â†’ Objects (instances)**
**Columns â†’ Attributes (fields of the object)**

So instead of doing this:

```sql
SELECT * FROM users WHERE id = 1;
```

You do:

```python
user = User.get(id=1)
```

Or in JavaScript:

```js
const user = await User.findByPk(1);
```

The ORM generates the SQL for you behind the scenes.

---

# ğŸ”§ **How an ORM Works (In Simple Steps)**

### **1. Schema Mapping**

The ORM reads your models (classes) and maps them to database tables.

Example model:

```python
class User(Base):
    id = Integer(primary_key=True)
    name = String()
```

The ORM knows this corresponds to SQL:

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT
);
```

---

### **2. Query Building**

Your method calls get turned into SQL queries.

Example:

```js
User.findAll({ where: { active: true } });
```

The ORM converts that into:

```sql
SELECT * FROM users WHERE active = TRUE;
```

---

### **3. Object Instantiation**

The returned rows are turned into objects in your language.

SQL result:

| id  | name  |
| --- | ----- |
| 1   | Alice |

becomes:

```python
User(id=1, name="Alice")
```

---

### **4. Change Tracking**

If you modify the objectâ€¦

```python
user.name = "Bob"
```

â€¦the ORM knows what changed and generates the correct SQL:

```sql
UPDATE users SET name = 'Bob' WHERE id = 1;
```

---

### **5. Relationship Handling**

ORMs handle foreign keys automatically:

- **One-to-many**
- **Many-to-many**
- **Join tables**
- **Nested queries / eager loading**

Example:

```js
const posts = await user.getPosts();
```

The ORM builds the join:

```sql
SELECT * FROM posts WHERE user_id = 1;
```

---

# â­ Advantages of ORMs

### **âœ” Faster development**

Write less SQL manually.

### **âœ” Database abstraction**

Switch between SQLite â†’ PostgreSQL â†’ MySQL with minimal changes.

### **âœ” Safer**

Prevents SQL injection by using parameterized queries.

### **âœ” Cleaner, more readable code**

Queries look like normal object operations.

---

# âš  When ORMs Are Not Ideal

ORMs can be problematic when:

- performance is critical
- queries become deeply complex
- you need raw SQL features or database-specific tuning

Many engineers use ORM **+ raw SQL together**.

---

# ğŸ’¡ Examples of Popular ORMs

### **JavaScript/TypeScript**

- Prisma
- Sequelize
- TypeORM
- Drizzle ORM

### **Python**

- SQLAlchemy
- Django ORM

### **Java**

- Hibernate / JPA

### **Ruby**

- ActiveRecord (Rails)

---

Edge Compatibility

Go to authjs.dev
Go Guides from the Navbar menu
Select Edge Compatibility from the left sidebar

We need to do this setup because we are making use of PostgreSql and Prisma which are running on the edge.

Hereâ€™s a clear, beginner-friendly explanation of **what an edge runtime is**, without assuming any technical background.

---

# ğŸ§  What Is an â€œEdge Runtimeâ€?

Think of the internet as a giant network where computers talk to each other.
When you visit a website, your request normally travels across the world to a **central server** (often in a big data center in one city). That server processes your request and sends the result backâ€”like a round-trip flight.

An **edge runtime** is a way of running code **closer to you**, right at the â€œedgeâ€ of the network.

---

# ğŸŒ The â€œEdgeâ€ Part

â€œ**Edge**â€ simply means **computers that are physically located closer to the user**â€”in many cities around the world.

Example:

- Instead of your request going from London â†’ New York â†’ London,
- it might go from London â†’ nearby edge server â†’ London.

Shorter trip â†’ faster response.

Companies like Cloudflare, Vercel, and Netlify have hundreds of these small edge locations globally.

---

# ğŸ§© The â€œRuntimeâ€ Part

A **runtime** is just the **environment that runs your code**.

You can think of it like:

- A kitchen where the cooking happens.
- Your code is the recipe.
- The runtime provides the tools (oven, stove, utensils) to run it.

Different runtimes have different tools.
For example:

- Node.js runtime (on a server)
- Browser runtime (JavaScript in Chrome)
- Edge runtime (JavaScript/WebAssembly at the network edge)

---

# âš¡ So What Is an Edge Runtime?

Putting it together:

ğŸ‘‰ **An edge runtime is a lightweight environment that runs your code on servers located close to the user.**

This makes apps:

- **faster** â†’ less distance traveled
- **more responsive** â†’ good for real-time features
- **more scalable** â†’ load is spread across many edge locations

But since itâ€™s lightweight, it often has:

- **fewer built-in features** than a full server (e.g., no access to full Node.js APIs)
- **limits on processing power**, because it must run quickly

---

# ğŸ“¦ Example to Make It Crystal Clear

Imagine a food delivery service.

### Traditional Server

1. You call the restaurant (in one city).
2. They confirm your address.
3. They send the food.

If the restaurant is far away, the call and delivery take longer.

### Edge Runtime

1. You call a **local branch** of the service.
2. They look up your info instantly.
3. They tell the main restaurant what to do.

The answering part is much faster because it's local.

In computing, that â€œlocal branchâ€ is the **edge runtime**.

---

# ğŸ¤– Real-World Uses

Edge runtimes are especially good for:

- Authentication checks
- A/B testing
- Redirects
- Personalizing websites
- Realtime chat or updates
- Rate limiting (blocking too many requests)
- API requests that need to be fast globally

---

# ğŸ‘ Summary (Beginner-Friendly)

- **Edge = close to user**
- **Runtime = system that runs your code**
- **Edge runtime = runs your code on nearby mini-servers so the website feels faster**

Itâ€™s like moving small pieces of your app closer to the user so each interaction is almost instant.

---

Clerk Middleware

Go to clerk.com
Go to Docs in the Navbar menu and select Nextjs from the expanded dropdown
Copy and paste the clerkMiddleware() code

---

http://localhost:3000/api/auth/signin?error=OAuthAccountNotLinked

---

Instructions to obtain the schema code:
Open authjs.dev
Click on Get Started button
Select Database from the left sidebar
Select Prisma from the official adapters list
Select Schema from the right sidebar
Copy the PostgreSQL schema code into this file
